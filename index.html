<html>
    <head>
        <meta charset="utf-8">
        <title>Interactive Map</title>
        <style>
            body {
                margin: 0;
            }
            canvas {
                display: block;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js" integrity="sha256-+5R1zw/Tcxp82QhhfAJlicTeM4LCzFxp6EvsZW3V9bE=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js" integrity="sha256-tHoAPGoNdhIR28YHl9DWLzeRfdwigkH7OCBXMrHXhoM=" crossorigin="anonymous"></script>

    </head>
    <body>

        <script>

            function wireframe(multilinestring, material) {
                console.log(multilinestring);

                const geometry = new THREE.Geometry();
                for (const P of multilinestring.coordinates) {
                    let p0 = new THREE.Vector3(P[0][0], P[0][1], 0);
                    for (let i = 1; i < P.length; ++ i) {

                        let p1 = new THREE.Vector3(P[i][0], P[i][1], 0);
                        geometry.vertices.push(p0, p1);
                        p0 = p1;
                        
                    }
                }

                return new THREE.LineSegments(geometry, material);
            }


            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            var renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);


            var geometry = new THREE.BoxGeometry();
            var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
            var cube = new THREE.Mesh(geometry, material);
            cube.userData = {
                name: "cube1",
                test: function () {
                    console.log("I am test cubybyyyyy")
                }
            }

            scene.add(cube);

            var topology;
            fetch('world_map.json').then((response) => {
                return response.json();
            }).then((data) => {
                console.log(data)
                topology = data;
                const mesh = topojson.mesh(topology, topology.objects.world_map);
                // console.log(mesh)
                let material = new THREE.LineBasicMaterial({color: 0xff0000});
                material.side = THREE.DoubleSide;
                // console.log(data.features[0].geometry)
                var map = wireframe(mesh, material);
                map.userData = {
                    name: "main map",
                    test: function () {
                        console.log("I am test maaaaapppppp!")
                    }
                }
                scene.add(map);
                // console.log(data);
            });

            camera.position.z = 200;
            camera.lookAt(scene.position);

            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();
            var INTERSECTED = null;
            function animate() {
                requestAnimationFrame(animate);

                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;

                // update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);

                // calculate objects intersecting the picking ray
                var intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {

                    if (INTERSECTED != intersects[0].object) {

                        if (INTERSECTED) 
                            INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                        

                        INTERSECTED = intersects[0].object;
                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                        INTERSECTED.material.color.setHex(0xffffff);
                        // console.log("this is: " + INTERSECTED.userData.name)
                        INTERSECTED.userData.test();

                    }

                } else {

                    if (INTERSECTED) 
                        INTERSECTED.material.color.setHex(INTERSECTED.currentHex);
                    

                    INTERSECTED = null;

                }

                for (var i = 0; i < intersects.length; i++) {

                    intersects[i].object.material.color.set(0xffffff);

                }

                renderer.render(scene, camera);
            }
            animate();


            document.addEventListener('wheel', onDocumentMouseWheel, false);
            function onDocumentMouseWheel(event) {
                camera.position.z -= event.wheelDeltaY * 0.05;
                camera.updateProjectionMatrix();
            }


            document.addEventListener('mousemove', onMouseMove, false);
            function onMouseMove(event) {
                event.preventDefault();

                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;
                
                if (event.buttons > 0) {
                    camera.position.x -= event.movementX / 5;
                    camera.position.y += event.movementY / 5;
                    camera.updateProjectionMatrix();
                }
            }

            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        </script>
    </body>
</html>
