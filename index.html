<html>
    <head>
        <meta charset="utf-8">
        <title>Interactive Map</title>
        <style>
            body {
                margin: 0;
            }
            canvas {
                display: block;
            }
            .country_name {
                position: fixed;
                bottom: 10%;
                left: 10%;
                font-size: 4rem;
                color: white;
                user-select: none;
                text-shadow: -1px 1px 0 #000, 1px 1px 0 #000, 1px -1px 0 #000, -1px -1px 0 #000;
                font-family: 'Roboto', sans-serif;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js" integrity="sha256-+5R1zw/Tcxp82QhhfAJlicTeM4LCzFxp6EvsZW3V9bE=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.min.js" integrity="sha256-tHoAPGoNdhIR28YHl9DWLzeRfdwigkH7OCBXMrHXhoM=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.0/anime.min.js" integrity="sha256-hBMojZuWKocCflyaG8T19KBq9OlTlK39CTxb8AUWKhY=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js" integrity="sha256-8IvN8DiAvwO7J3WLqoRDg2/XfkOxcB0urCTU4x0kBOM=" crossorigin="anonymous"></script>
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap" rel="stylesheet">
        <script src="Country.js"></script>
    </head>
    <body>
        <div class="country_name"></div>

        <script>
            let scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 200;
            camera.lookAt(scene.position);

            let renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            let countries = [];
            let raycastObjs = [];
            let lineObjs = [];
            let raycaster = new THREE.Raycaster();
            let mouse = new THREE.Vector2();
            let INTERSECTED = null;
            let CLICKED = null;

            init();
            setupEventListeners();
            createGUI();
            animate();


            function init() {
                fetch('world_map.json').then((response) => {
                    return response.json();

                }).then((topology) => {

                    let features = topojson.feature(topology, topology.objects.world_map);
                    console.log(features);

                    for (const feature of features.features) {
                        countries.push(new Country(feature.geometry, feature.properties))
                    }
                    console.log(countries);


                    for (const country of countries) {
                        let shape = country.createShape();
                        let line = country.createLine();
                        raycastObjs.push(shape);
                        lineObjs.push(line)

                        // Workaround due to South Africa not having proper hole rendering
                        if (country.properties.NAME === "Lesotho") {
                            shape.position.z = .1;
                            line.position.z = .1;
                        }

                        scene.add(shape);
                        scene.add(line);
                    }

                    // Troubleshooting
                    // scene.add(countries.filter((x) => { return x.properties.NAME == "United States of America"})[0].createLine() );
                    // console.log(countries.filter((x) => { return x.properties.NAME == "United States of America"}))
                });
            }


            function animate() {
                requestAnimationFrame(animate);

                raycaster.setFromCamera(mouse, camera);

                let intersects = raycaster.intersectObjects(raycastObjs);

                if (intersects.length > 0) {
                    if (INTERSECTED && INTERSECTED != CLICKED) {
                        INTERSECTED.material.color.setHex(INTERSECTED.userData.shapeColor);
                    }

                    INTERSECTED = intersects[0].object;

                    if (INTERSECTED != CLICKED) {
                        INTERSECTED.material.color.setHex(0x666666);
                    }

                } else {
                    if (INTERSECTED && INTERSECTED != CLICKED) {
                        INTERSECTED.material.color.setHex(INTERSECTED.userData.shapeColor);
                    }
                } 
                
                renderer.render(scene, camera);
            }

            function setupEventListeners() {
                document.addEventListener('click', onDocumentClick, false);
                function onDocumentClick(event) {
                    let intersects = raycaster.intersectObjects(raycastObjs);

                    if (intersects.length > 0) {

                        if (CLICKED) {
                            CLICKED.material.color.setHex(CLICKED.userData.shapeColor);
                        }

                        CLICKED = intersects[0].object;
                        CLICKED.material.color.setHex(0x164B91);

                        document.querySelector(".country_name").innerText = CLICKED.userData.properties.NAME;

                    } else {

                        if (CLICKED) {
                            CLICKED.material.color.setHex(CLICKED.userData.shapeColor);
                            document.querySelector(".country_name").innerText = "";
                        }

                        CLICKED = null;
                    }
                }


                document.addEventListener('wheel', onDocumentMouseWheel, false);
                function onDocumentMouseWheel(event) {
                    let moveToZ = camera.position.z - event.wheelDeltaY * 0.4;
                    moveToZ = (moveToZ < 30) ? 30 : moveToZ;
                    moveToZ = (moveToZ > 200) ? 200 : moveToZ;

                    anime({
                        targets: camera.position,
                        z: moveToZ,
                        duration: 500,
                        easing: 'easeOutQuad'
                    })
                }

                document.addEventListener('mousemove', onMouseMove, false);
                function onMouseMove(event) {
                    event.preventDefault();

                    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                    mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                    if (event.buttons > 0) {
                        camera.position.x -= event.movementX / 5;
                        camera.position.y += event.movementY / 5;
                    }
                }

                window.addEventListener('resize', onWindowResize, false);
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;

                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            }


            function createGUI() {
                let Test = {
                    stagger: function (zPosition) {
                        let staggerObjs = raycastObjs.map((obj) => {
                            return obj.position
                        });
                        let staggerLines = lineObjs.map((obj) => {
                            return obj.position
                        });

                        anime({targets: staggerObjs, z: zPosition, delay: anime.stagger(25), easing: 'easeInQuad'})

                        anime({targets: staggerLines, z: zPosition, delay: anime.stagger(25), easing: 'easeOutQuad'})
                    },
                    staggerIn: function () {
                        this.stagger(0);
                    },
                    staggerOut: function () {
                        this.stagger(300);
                    }
                }
                let gui = new dat.GUI();
                let folder1 = gui.addFolder('Test Animations');
                folder1.add(Test, 'staggerIn');
                folder1.add(Test, 'staggerOut');
                folder1.open();
            }
        </script>
    </body>
</html>
